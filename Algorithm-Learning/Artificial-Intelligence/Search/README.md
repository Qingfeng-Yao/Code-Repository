## 搜索
- 寻找一系列`actions`来达到目标的过程
- 用搜索求解问题
  - 在某个可能的解空间(状态空间)内寻找一个解(状态)
  - 状态空间：通常以图的形式出现，节点对应问题的状态，节点之间的边对应状态转移的可行性，边上的权对应转移所需的代价
    - 后继函数：SUCC(state) --> subset of states
  - 问题的解可能是图中的一个状态，或者是从开始状态到某个状态的一条路径，再或者是达到目标所花费的代价
- 如：8-Puzzle(8-数码问题)，更一般的为(n^2-1)-puzzle
  - 8-Puzzle的状态空间大小为 `9!`；但只有一半的状态能从任意给定状态达到；实际的状态空间是`9!`而非`9!/2`
  - `Permutation Inversions`: 对于任意给定的tile，出现在其后的tile的数目(满足后者的值小于前者的值)；所有tile对应的数目和+空tile所在行号(从1开始)=Permutation Inversions(N)
    - 空tile的水平移动不会导致N值的变化，空tile的竖直移动将会导致N值偶数的变化量
  - 要使目标状态g可从状态s达到，充要条件是N(g)和N(s)具有相同的奇偶性
  - 创建完整的状态图表示通常是不可行的，一般是通过探索一小部分图(搜索树)来解决问题
    - 某些状态会被访问多次
    - 如果状态允许被重复访问，则尽管状态空间有限，搜索树会是无限的
    - 一个节点的深度=从根节点出发到该节点的path的长度
    - 搜索树中节点的expansion：求解该节点状态的后继函数，并生成后继状态节点
    - 搜索树的Fringe：还未扩展的的节点集合；以优先队列`FRINGE`被执行(涉及插入和删除)
    - `FRINGE`中节点的顺序定义搜索策略
- 完备性：如果一个搜索算法在任何时候都能找到一个解，那么它就是完备的
- 最优性：当一个解存在时，如果它返回一个最小代价路径，则搜索算法是最优的
- 复杂性：衡量算法所需的时间和内存
- 何时使用搜索技术：当搜索空间小且没有其他可用技术或不值得发展一个更有效的技术；当搜索空间大且没有其他可用技术同时存在好的启发式函数
  
### Simple Problem-Solving-Agent Algorithm
- 由已知条件确定初始状态，由要求达到的目标确定目标状态
- 确定后继函数
- 确定解
- 如：8-Queens Problem
  - 将8个王后放置在棋盘上，要求在同一行、同一列、同一对角线上只有一个王后
  - 状态：0、1、...、8个王后在棋盘上的所有排列(`64*63*...*57`个状态) | k=0,1,...,8 leftmost columns with no two queens attacking each other(`2057`个状态)
  - 初始状态：0个王后在棋盘上
  - 后继函数：将一个王后放置在一个空的位置上 | 将一个王后放置在leftmost列上一个空的位置上，要求不能与已经放置好的王后冲突
  - 无`arc cost`
  - 目标测试：8个王后在棋盘上，同时没有互相攻击 | 放好8个王后
- n-Queens Problem：解是一个目标节点，不是一个`path`到这个节点
- Path Planning：离散状态空间和连续状态空间
- Assembly (Sequence) Planning
  - 初始状态：单个零件；目标状态：完整的部件
  - 后继函数：merge two subassemblies
  
### 盲目搜索/非启发式搜索：无信息搜索
* 不会利用状态描述来排序`FRINGE`，它们只利用搜索树中节点的位置
* 广度优先：新节点被插在`FRINGE`的末尾
  * 搜索树的分支因子b：任意状态的后继者的最大数目
  * 搜索树中最浅目标节点的深度d：初始节点和目标节点之间路径的最小长度
  * 该算法是完备的，当step cost是1时是最优的(或者说当step cost是节点深度的非递减函数时是最优的)
  * 要生成O(b^d)个节点(b+b^2+...+b^d=b(b^d-1)/(b-1)) --> 时间和空间复杂度是O(b^d)
  * 当一个问题无解时，广度优先会永远运行下去
  * 双向策略：两个`FRINGE`队列；时间和空间复杂度是O(b^(d/2))
  * 广度优先的变种：Uniform-Cost(每一条arc都有cost c大于等于某个阈值大于0)
    * `FRINGE`中节点按照g(N)的升序排列(其中g(N)是节点N的cost)
    * 目标测试是在节点要扩展时进行的，而非节点被生成时
    * 避免多次访问某些状态：当一个节点N要被扩展时，到N的路径是最佳路径，此时将N对应的状态s存储到CLOSED中；当一个新节点生成时，如果它的状态在CLOSED中，则舍弃N；若在`FRINGE`中有节点与N的状态一致，则舍弃那个具有最高cost的节点
* 深度优先：新节点被插在`FRINGE`的开头
  * 搜索树的分支因子b：任意状态的后继者的最大数目
  * 搜索树中最浅目标节点的深度d：初始节点和目标节点之间路径的最小长度
  * m: 叶子节点的最大深度
  * 对有限搜索树是完备的，不是最优的
  * 在最坏情况下要生成O(b^m)个节点(b+b^2+...+b^m) --> 时间复杂度是O(b^m)，空间复杂度是O(bm)或O(m)
  * 深度受限：depth cutoff k (depth at which nodes are not expanded)
  * 迭代加深：同时兼顾深度和广度；针对不同的k执行深度受限的深度优先搜索
    * 该算法是完备的，当step cost是节点深度的非递减函数时是最优的
    * 时间复杂度O(b^d)，空间复杂度O(bd)或O(d)
      
### 启发式搜索：有信息搜索
* 利用状态描述来排序`FRINGE`：最`promising`的节点排在`FRINGE`的开头(比如与目标状态相比，tiles错误放置的数目)
* `Best-First Search`: 利用状态描述来估计每一个搜索节点有多好
  * 评估函数f将搜索树中的每一个节点映射为一个实数f(N)(非负)；f(N)一般是一个estimated cost，则越小越好
  * 以f的升序排序`FRINGE`；若节点有相同的f，则任意排列
  * 这里的`Best`不是指生成路径的质量，该搜索一般不会生成最优路径
  * f(N)可以估计通过N的解决路径的cost/f(N)=g(N)+h(N)，或者从N到目标节点的路径的cost/f(N)=h(N)；后者对应Greedy best-search；其中h(N)是一个heuristic函数，非负，比如可以是与目标状态相比有标号的tiles错误放置的数目/定义1、有标号的tile与它的目标位置的曼哈顿距离之和/定义2、permutation inversions之和/定义3
  * 若状态空间是无限的，一般该搜索是不完备的；若状态空间是有限的，且不抛弃重复访问的状态节点，则一般该搜索是不完备的；若状态空间是有限的，且抛弃重复访问的状态节点，则该搜索是完备的，但不是最优的
  * Admissible Heuristic：让h*(N)为从N到目标节点的最优路径的cost，则该启发式函数是admissible当h(N)位于`[0,h*(N)]`之间。一个admissible启发式函数总是乐观的
  * f(N)的三个定义中，定义1是admissible，定义2是admissible，定义3不是admissible
  * 一个可容许的启发式通常可以被看作是一个松弛`relaxed`问题的最优解的代价
* `A* Search`: 
  * f(N)=g(N)+h(N)，其中g(N)为到目前为止找到的到N的最佳路径的cost，h(N)为可容许的启发式函数。要求每一条arc都有cost c大于等于某个阈值大于0。目标测试是在节点要扩展时进行的，而非节点被生成时。满足以上条件的best-first搜索被称为`A* Search`
  * `A*`是完备和最优的，当重复访问状态的节点没有被抛弃
     * 若解存在，搜索终结并返回一个解
     * 当问题没解时，如果状态空间无限，搜索会无限进行下去；其他情况则会花很多时间来终结。所以搜索会给一个时间限制，如果在限制时间内没找到解，则停止。
     * 针对重复访问状态，如果抛弃这个新的节点，那么搜索算法接下来扩展目标节点并返回一个非最优解；当重复访问状态的节点没有被抛弃，搜索将以一个最优解结束，但同时搜索树的大小会是已访问状态数的指数。如果到该状态的新路径的cost大于等于上一条路径，则可抛弃重复访问状态的节点，即如果一个节点重新访问其祖先已经访问过的状态，则可以丢弃该节点
     * 对于consistent启发式函数，有一种更有效的方法来处理重新访问的状态：1)当一个节点被扩张时，将其状态存储到`CLOSED`；2)当生成一个新节点时，若其状态在`CLOSED`中，则抛弃该节点；若在fringe中存在与该节点状态一致的节点，则任意抛弃这两个节点中的一个
       * 一个consistent启发式函数是可容许的，但一个可容许启发式函数可能不是consistent(大部分可容许启发式函数是consistent)
       * 如果h是consistent，那么每当`A*`扩展一个节点时，它就已经找到了一个到达该节点状态的最优路径
  * `迭代加深A*/IDA*`：通过对f的值应用截断来减少`A*`的内存需求，h是一致启发式函数
     * 优点：完备、最优；比`A*`需要更少内存；Avoid the overhead to sort the fringe
     * 缺点：无法避免重新访问不在当前路径上的状态；Available memory is poorly used
* Local Search：light-memory搜索方法；没有搜索树；只有当前状态被表示
  * 仅适用于路径不相关的问题(例如，8-queen)，unless the path is encoded in the state
  * 与优化技术有许多相似之处
  * 并行的局部搜索技术(同时执行多个局部搜索，但不独立执行)
     * Beam search
     * Genetic algorithms

### 对抗搜索/博弈
- 有完整信息的(所有的状态都是完全可观测的)、确定性的、轮流行动的(如MAX先行)、两个游戏者(如MIN和MAX)的零和游戏
  - 在每个回合中，必须在指定的时间限制内选择要执行的操作
- 博弈树`game tree`：其中结点是状态(如MAX结点即此时该MAX行动)，边是移动；终止状态(一位游戏者的标志占领一行、一列、一对角线或所有方格都被填满)可根据游戏规则赋予效用值
  - 评估函数：`e(s)`，s是状态，e是启发式函数，估计s对MAX有多有利
  - 博弈树的深度为一步，包括两个单方招数，每个单方招数称为一层`ply`
  - 除终止结点显示的是MAX的效用值外，其他结点标的是它们的极大极小值`minmax`(back up: 对于MIN结点取后继的最小值，对于MAX结点取后继的最大值)
    - 效用值的计算(针对井字游戏`tic-tac-toe`)：行、列、对角线open for MAX的数目 - 行、列、对角线open for MIX的数目
  - 对于MAX结点，它的最佳指向是有最高的极小极大值的后继；对于MIN结点，它的最佳指向是有最低的极小极大值的后继
- 极小极大算法
  - alpha-beta剪枝：深度优先
  - alpha值是MAX结点的下界，beta值是MIN结点的上界
  - 假设博弈树的均匀分支因子为b，Minimax examines O(b^h) nodes，即alpha-beta的最坏情况。alpha-beta的gain最大(当MAX节点的MIN孩子以降序backed up值排列，MIN节点的MAX孩子以升序backed up值排列)，此时alpha-beta examines O(b^h/2) nodes。如果节点随机排序，由alpha-beta检查的节点平均数目是O(b^3h/4)
  - 节点的启发式排序：Order the children of a node according to the values backed-up at the previous iteration

